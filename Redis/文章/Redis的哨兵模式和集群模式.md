# Redis的哨兵模式和集群模式

## 哨兵模式
哨兵模式是redis高可用的实现方式之一
使用一个或者多个哨兵(Sentinel)实例组成的系统，对redis节点进行监控，在主节点出现故障的情况下，能将从节点中的一个升级为主节点，进行故障转义，保证系统的可用性。
![image](https://user-images.githubusercontent.com/87458342/133224644-c9f48939-2704-4118-abe8-1c7da6870af7.png)

### 哨兵们是怎么感知整个系统中的所有节点(主节点/从节点/哨兵节点)的

1. 首先主节点的信息是配置在哨兵(Sentinel)的配置文件中
2. 哨兵节点会和配置的主节点建立起两条连接命令连接和订阅连接
3. 哨兵会通过命令连接每10s发送一次INFO命令，通过INFO命令，主节点会返回自己的run_id和自己的从节点信息
4. 哨兵会对这些从节点也建立两条连接命令连接和订阅连接
5. 哨兵通过命令连接向从节点发送INFO命令，获取到他的一些信息
* a. run_id
* b. role
* c. 从服务器的复制偏移量 offset
* d. 等
6. 因为哨兵对与集群中的其他节点(主从节点)当前都有两条连接，命令连接和订阅连接
* a. 通过命令连接向服务器的_sentinel:hello频道发送一条消息，内容包括自己的ip端口、run_id、配置纪元(后续投票的时候会用到)等
* b. 通过订阅连接对服务器的_sentinel:hello频道做了监听，所以所有的向该频道发送的哨兵的消息都能被接受到
* c. 解析监听到的消息，进行分析提取，就可以知道还有那些别的哨兵服务节点也在监听这些主从节点了，更新结构体将这些哨兵节点记录下来
* d. 向观察到的其他的哨兵节点建立命令连接----没有订阅连接

### 哨兵模式下的故障迁移

#### 主观下线
哨兵(Sentinel)节点会每秒一次的频率向建立了命令连接的实例发送PING命令，如果在down-after-milliseconds毫秒内没有做出有效响应包括(PONG/LOADING/MASTERDOWN)以外的响应，哨兵就会将该实例在本结构体中的状态标记为SRI_S_DOWN主观下线

#### 客观下线
当一个哨兵节点发现主节点处于主观下线状态是，会向其他的哨兵节点发出询问，该节点是不是已经主观下线了。如果超过配置参数quorum个节点认为是主观下线时，该哨兵节点就会将自己维护的结构体中该主节点标记为SRI_O_DOWN客观下线
询问命令SENTINEL is-master-down-by-addr <ip> <port> <current_epoch> <run_id>
  
参数|	意义
:-------|:----------
ip/port|	当前认为下线的主节点的ip和端口
current_epoch|	配置纪元
run_id|	*标识仅用于询问是否下线 有值标识该哨兵节点希望对方将自己设置为leader 询问时用*，选举时用run_id
  
### leader选举
在认为主节点客观下线的情况下,哨兵节点节点间会发起一次选举，命令还是上面的命令SENTINEL is-master-down-by-addr <ip> <port> <current_epoch> <run_id>,只是run_id这次会将自己的run_id带进去，希望接受者将自己设置为主节点。如果超过半数以上的节点返回将该节点标记为leader的情况下，会有该leader对故障进行迁移
  
### 故障迁移
1. 在从节点中挑选出新的主节点
* a. 通讯正常
* b. 优先级排序
* c. 优先级相同是选择offset最大的
2. 将该节点设置成新的主节点 SLAVEOF no one,并确保在后续的INGO命令时，该节点返回状态为master
3. 将其他的从节点设置成从新的主节点复制, SLAVEOF命令
4. 将旧的主节点变成新的主节点的从节点
  
### 优缺点
* 优点: 高可用，在主节点故障时能实现故障的转移
* 缺点：好像没办法做到水平拓展，如果内容很大的情况下
  
## 集群模式
官方提供的分布式方案(槽指派/重新分片/故障转移)
  
集群内的节点，都会有个数据结构存储整个集群内的节点信息
  
```C
//整体
struct clusterState{
  clusterNode *mySelf;
  ....
  dict *nodes;  //集群内的所有节点
}

// 单个节点
struct clusterNode {
  char name[];
  char ip[];
  int port;
  clusterLink *link;  //保存节点间，连接的信息
  int flags;    //状态标记
}

//节点间连接的信息
struct clusterLink{
  mstime_t ctime;  //创建时间
  int fd; //tcp套接字描述符
  sds sndbuf;  // 输出缓存区
  sds rcvbuf;  //输入缓存区
  struct clusterNode *node;
}
```
  
![image](https://user-images.githubusercontent.com/87458342/133225521-65a0bae7-2e99-4a48-99bc-4dd0a9f608b6.png)
  
### 槽指派
redis集群可以被分为16384个槽，只有这些槽全被指派了处理的节点的情况下，集群的状态才能是上线状态(ok)
操作redis集群的时候，将key作为参数，就可以计算出对应的处理槽上，所以存储等操作都应该在该槽对应的节点上。通过这种方式，可以完美的实现集群存储的水平拓展。
  
```C
def slot_number(key):
  return CRC16(key) & 16383
//得到的结果就是槽的序号
```
  
槽指派的信息是怎么存储的
  
```C
struct clusterState{
  clusterNode *slots[16384]
 }

struct clusterNode{
  unsigned char slots[16384/8]
}
```
  
通过上面两个结构体中的定义可以看出，槽指派的信息是分了两种方式，保存在结构体里面。
  
![image](https://user-images.githubusercontent.com/87458342/133225842-864c23f3-8f05-40e0-abb2-3b09a734664e.png)
  
![image](https://user-images.githubusercontent.com/87458342/133225896-1b879018-f3a9-4bce-8df8-6f6631ec5f89.png)

分两种存储的好处
1. 如果需要判断某一个节点负责的槽，只需要获取方式二中的数组做判断就可以
2. 如果找某个槽是哪个节点负责，只需要获取方式一的列表，一查就知道
  
### 重新分片
将已经指派给节点的槽，重新执行新的节点。
![image](https://user-images.githubusercontent.com/87458342/133226039-e6263637-d199-4cbe-808b-a341f69cace8.png)
  
### 故障转移
#### 发现故障节点
1. 集群内的节点会向其他节点发送PING命令，检查是否在线
2. 如果未能在规定时间内做出PONG响应，则会把对应的节点标记为疑似下线
3. 集群中一半以上负责处理槽的主节点都将主节点X标记为疑似下线的话，那么这个主节点X就会被认为是已下线
4. 向集群广播主节点X已下线,大家收到消息后都会把自己维护的结构体里的主节点X标记为已下线
#### 从节点选举
1. 当从节点发现自己复制的主节点已下线了，会向集群里面广播一条消息，要求所有有投票权的节点给自己投票(所有负责处理槽的主节点都有投票权)
2. 主节点会向第一个给他发选举消息的从节点回复支持
3. 当支持数量超过N/2+1的情况下，该从节点当选新的主节点
#### 故障的迁移
1. 新当选的从节点执行 SLAVEOF no one,修改成主节点
2. 新的主节点会撤销所有已下线的老的主节点的槽指派，指派给自己
3. 新的主节点向集群发送命令，通知其他节点自己已经变成主节点了，负责哪些槽指派
4. 新的主节点开始处理自己负责的槽的命令
#### 集群模式和哨兵模式的区别#
1. 哨兵模式监控权交给了哨兵系统，集群模式中是工作节点自己做监控
2. 哨兵模式发起选举是选举一个leader哨兵节点来处理故障转移，集群模式是在从节点中选举一个新的主节点，来处理故障的转移


